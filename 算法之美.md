# 一、复杂度分析


1.  时间复杂度

*  分析方法
   1. 加法法则：总复杂度等于量级最大的那段代码的复杂度

   2. 乘法法则: 总复杂度等于嵌套内外层代码的复杂度的乘积
  
*  四种时间复杂度概念
   1. 最好时间复杂度：最好的情况下，执行这段代码的时间复杂度

   2. 最坏时间复杂度：最坏的情况下，执行这段代码的时间复杂度

   3. 平均时间复杂度：用于代码在不同情况下的时间复杂度有量级的差异，要考虑不同的情况发生的概率，即加权平均时间复杂度

   4. 均摊时间复杂度：用于大部分情况下时间复杂度很低，个别情况下时间复杂度很高，且这些操作之间有前后连贯的时序关系。
                     每一次O(n)时间复杂度操作后都跟着n-1次O(1)时间复杂度的操作，可以将耗时多的那次操作的时间均摊到加下来的n-1次耗时少的操作

* 常见时间复杂度量级
   1. O(1)                常量级，不随数据规模n变化
   2. O(logn)、O(nlogn)   对数级、线性对数级，由于用大O表示时间复杂度忽略系数，又可通过换底公式，忽略对数的底
   3. O(m+n)、O(m*n)      时间复杂度由两个无关的数据规模组成，二者都要保留

2.  空间复杂度

* 常见空间复杂度O(1)、O(logn)、O(n)、O(nlogn)、O(n2)


# 二、数组、链表、栈和队列

1.  数组

* 定义：一组连续的内存空间存储一组具有相同类型的数据
* 随机访问特性：支持在O(1)的时间复杂度内按照下标快速访问数组中的元素
* 寻址公式：a[k]_address = base_address + k*data_type_size
   * 若数组下标从1开始，通过寻址公式可以看到，每次都要有一个(k-1)的减法操作，这对于数组这个基础数据结构的最基本操作，效率的优化要做到极致，因此数组下标从0开始
* 低效的插入和删除操作
   * 当数组中数据有序时，插入删除时只能进行数据移动；当数组中数据无需排序时，若要在a[i]插入元素，为了避免大规模的数据移动，可以将a[i]的数据移动到数组最后，再将新元素插入a[i]的位置。
   * 删除操作时，每次删除操作并不是真的删除数据，而只是标记数据已删除，当数组中没有更多的存储空间时，再集中执行删除操作，这样可以大大减少删除操作的数据搬移次数。类似于JVM的标记清除“垃圾”回收算法的核心思想。
* 警惕数组访问越界问题
   * 在C语言中并没有规定数组越界访问时编译器如何处理，就会导致莫名其妙的运行错误，调试难度极大。很多计算机病毒也正利用数组越界访问非法地址的漏洞来攻击系统。在JAVA中会进行越界检查，抛出java.lang.ArrayIndexOutOfBoundsException异常。

* 容器和数组的异同(以java中的ArrayList为例)
   * ArrayList
      * 优势：可以将很多数组的操作细节封装起来，且支持动态扩容。
      * 缺点：无法存储int、long等基本类型，需要封装为Integer类和Long类，且有一定的性能消耗。
   * 数组：适用于数据大小已知且数据操作简单，多维数组用数组表示更加直观， 或是进行底层的开发性能优化需要做到极致。

* 数据结构中的数组和各种编程语言中的数组的区别

   * C/C++中数组的实现方式
      * 完全符合数据结构中数组的标准定义，利用连续空间存储相同类型的数据
      * 二维数组“先按行，再按列”的方式连续存储
      * 二维数组a[i][j]的寻址公式： address_a[i][j]=address_base + (i*m+j)*data_size

   * Java中数组的实现方式
      * 基本数据类型数组：int arr[] = new int[3] arr存储在栈中,arr存储的是数组空间的首地址。 new申请的空间在堆中，
      * 对象数组：Person arr[] = new Person[3]  对象数组中存储的是对象在内存中的地址，而不是对象本身，对象本身在内存中也不是连续存储。
      * 二维数组存储基本类型数据：int arr[] = new int[3][]  一维数组中连续存储的是第二位数组的地址，第二维数组各自占据一片连续空间，但彼此之间并不一定连续。
      * 二维数组存储对象：在上一条的基础上，第二维数组中每个每个元素存储的是其对象的地址，各个对象并不连续存储。

   * JavaScript中数组的实现方式
      * 如果数值中是相同类型的数据，那么用数据结构中的数组来实现。
      * 如果数组中是不同类型的数据，那么用类似于哈希表的结构来存储数据，也就是说，数据并不连续存储在内存上
      * 如果向存储相同类型的数组中插入一个不同类型的数据，那么js会将底层的数据结构从数组换成哈希表。



