# 一、复杂度分析


1.  时间复杂度

*  分析方法
   1. 加法法则：总复杂度等于量级最大的那段代码的复杂度

   2. 乘法法则: 总复杂度等于嵌套内外层代码的复杂度的乘积
  
*  四种时间复杂度概念
   1. 最好时间复杂度：最好的情况下，执行这段代码的时间复杂度

   2. 最坏时间复杂度：最坏的情况下，执行这段代码的时间复杂度

   3. 平均时间复杂度：用于代码在不同情况下的时间复杂度有量级的差异，要考虑不同的情况发生的概率，即加权平均时间复杂度

   4. 均摊时间复杂度：用于大部分情况下时间复杂度很低，个别情况下时间复杂度很高，且这些操作之间有前后连贯的时序关系。
                     每一次O(n)时间复杂度操作后都跟着n-1次O(1)时间复杂度的操作，可以将耗时多的那次操作的时间均摊到加下来的n-1次耗时少的操作

* 常见时间复杂度量级
   1. O(1)                常量级，不随数据规模n变化
   2. O(logn)、O(nlogn)   对数级、线性对数级，由于用大O表示时间复杂度忽略系数，又可通过换底公式，忽略对数的底
   3. O(m+n)、O(m*n)      时间复杂度由两个无关的数据规模组成，二者都要保留

2.  空间复杂度

* 常见空间复杂度O(1)、O(logn)、O(n)、O(nlogn)、O(n2)


# 二、数组、链表、栈和队列

1.  数组

* 定义：一组连续的内存空间存储一组具有相同类型的数据
* 随机访问特性：支持在O(1)的时间复杂度内按照下标快速访问数组中的元素
* 寻址公式：a[k]_address = base_address + k*data_type_size
   * 若数组下标从1开始，通过寻址公式可以看到，每次都要有一个(k-1)的减法操作，这对于数组这个基础数据结构的最基本操作，效率的优化要做到极致，因此数组下标从0开始
* 低效的插入和删除操作
   * 当数组中数据有序时，插入删除时只能进行数据移动；当数组中数据无需排序时，若要在a[i]插入元素，为了避免大规模的数据移动，可以将a[i]的数据移动到数组最后，再将新元素插入a[i]的位置。
   * 删除操作时，每次删除操作并不是真的删除数据，而只是标记数据已删除，当数组中没有更多的存储空间时，再集中执行删除操作，这样可以大大减少删除操作的数据搬移次数。类似于JVM的标记清除“垃圾”回收算法的核心思想。
* 警惕数组访问越界问题
   * 在C语言中并没有规定数组越界访问时编译器如何处理，就会导致莫名其妙的运行错误，调试难度极大。很多计算机病毒也正利用数组越界访问非法地址的漏洞来攻击系统。在JAVA中会进行越界检查，抛出java.lang.ArrayIndexOutOfBoundsException异常。

* 容器和数组的异同(以java中的ArrayList为例)
   * ArrayList
      * 优势：可以将很多数组的操作细节封装起来，且支持动态扩容。
      * 缺点：无法存储int、long等基本类型，需要封装为Integer类和Long类，且有一定的性能消耗。
   * 数组：适用于数据大小已知且数据操作简单，多维数组用数组表示更加直观， 或是进行底层的开发性能优化需要做到极致。

* 数据结构中的数组和各种编程语言中的数组的区别

   * C/C++中数组的实现方式
      * 完全符合数据结构中数组的标准定义，利用连续空间存储相同类型的数据
      * 二维数组“先按行，再按列”的方式连续存储
      * 二维数组a[i][j]的寻址公式： address_a[i][j]=address_base + (i*m+j)*data_size

   * Java中数组的实现方式
      * 基本数据类型数组：int arr[] = new int[3] arr存储在栈中,arr存储的是数组空间的首地址。 new申请的空间在堆中，
      * 对象数组：Person arr[] = new Person[3]  对象数组中存储的是对象在内存中的地址，而不是对象本身，对象本身在内存中也不是连续存储。
      * 二维数组存储基本类型数据：int arr[] = new int[3][]  一维数组中连续存储的是第二位数组的地址，第二维数组各自占据一片连续空间，但彼此之间并不一定连续。
      * 二维数组存储对象：在上一条的基础上，第二维数组中每个每个元素存储的是其对象的地址，各个对象并不连续存储。

   * JavaScript中数组的实现方式
      * 如果数值中是相同类型的数据，那么用数据结构中的数组来实现。
      * 如果数组中是不同类型的数据，那么用类似于哈希表的结构来存储数据，也就是说，数据并不连续存储在内存上
      * 如果向存储相同类型的数组中插入一个不同类型的数据，那么js会将底层的数据结构从数组换成哈希表。


2. 链表

* 存储结构：通过指针将一组零散的内存块串联起来使用
   * 与数组的存储结构相比，数组擅长按下表随机访问，链表擅长插入、删除操作
* 定义：链表中，每个节点除了要存储数据，还要额外存储下一个节点的位置(next指针);
  ```java
  public class LinkedList{      //单链表的定义
    public class Node {
      public int data;
      public Node next;
    }
    private Node head = null;
  }
  ```

* 单链表的操作：查找、插入和删除
  ```java
  public Node find (int value){       //查找值为value的节点
    Node p = head;
    while(p!=null && p.data!=value){
      p = p.next;
    }
    return p;
  }

  void insert(Node b, Node x){        //在b节点后插入x节点
    if(b == null){        //在链表头部
      x.next = head;
      head = x;
    }
    else{
      x.next = b.next;
      b.next = x;
    }
  }

  void remove(Node a, Node b){        //删除a节点后的b节点
    if(a == null){
      head = head.next;
    }
    else{
      a.next = a.next.next;
    }
  }
  //若不知道前驱节点a,则要从头遍历链表找到b节点的前驱结点

  ```
* 循环链表：单链表的尾结点的next指针指向null,而循环链表的next指针指向头结点。
* 双向链表：单链表只能从前往后遍历，每个节点只有next指针，而双向链表有两个遍历方向，还有prev指针指向它的前驱节点。
  ```java
  public class DoublyLinkedList{      //双向链表的定义
    public class Node {
      public int data;
      public Node prev;
      public Node next;
    }
    private Node head = null;
  }
  ```
  实际软件开发中，从链表中删除元素主要有两种情况：
  1. 删除值为给定值的节点
  2. 删除给定指针指向的节点
  
  对于第一种情况，使用单链表或双向链表都需要从头开始遍历链表，时间复杂度都是O(n)；
  对于第二种情况，单链表删除操作的时间复杂度为O(n),双向链表的时间复杂度为O(1)；
  ```java
  void remove(Node q){        //在单链表中删除q节点
    if(q == null){            //当q是空节点时
      return;
    }
    if(head = q){             //当q是头结点时
      head = q.next;
      return;
    }
    Node p = head;
    while(p!=null){           //当p指向尾结点的next之前
      if(p.next == q){        //当p是q的先驱节点时
        p.next = p.next.next;
        return;
      }
      p = p.next;             
    }
  }

  void remove(Node q){        //在双向链表中删除q节点
    if(q = null){             //当q是空节点时
      return;
    }
    if(q.prev == null){       //当q是头结点时
      head = q.next;
      return;
    }
    q.prev.next = q.next;
  }

  ```
* 双向循环链表：将循环链表和双向链表结合形成的链表结构

* 链表和数组的性能对比
   * 数组的优缺点：数组使用连续的内存空间存储数据，可以有效地利用CPU的缓存机制，提高访问效率；数组的大小固定，声明时过大会导致内存不足或内存浪费，过小都会需要扩容，非常耗时。
   * 链表的优缺点：链表没有大小的限制，支持动态扩容；但链表在内存中不是连续存储，没办法预读，对CPU缓存不友好。
   因此，数组适合内存紧缺的开发场景，因为链表需要存储额外的next、prev指针，内存消耗更多。而链表频繁的插入删除操作，会导致频繁的内存申请和释放，容易产生内存碎片。

* 基于链表实现LRU（最近最少使用）缓存淘汰算法
   1. 建立一个有序单链表，将最新访问的数据插入链表头部，那么越靠近尾部的节点，就是越不常访问的节点，当要访问数据时，就从头开始遍历链表。
   2. 如果此数据已经缓存在链表中，那么就遍历访问到这个节点，将这个节点从当前位置删除并重新插入链表头部；
   3. 如果此数据没有缓存在链表中
      * 如果此时缓存未满，则将新的数据节点插入链表的头部。
      * 如果此时缓存已满，则将链表尾部最后一个节点删除，再将新的数据节点插入链表头部。
  由于每种情况都要遍历一次链表，因此缓存访问时间复杂度为O(n)。
  实际上可以引入哈希表来记录每个节点在链表中的位置，将时间复杂度降为O(1)。



